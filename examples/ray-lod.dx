import plot

'## Types

def Vec (n: Int) : Type = Fin n => Float
Position = Vec 3
Direction = Vec 3
Distance = Float
Ray = (Position & Direction)
Voxel = (Float & Float & Float)
LoD = Fin 8
Octant = Fin 8
def AABox : Type = (Position & Position)  -- opposite corners

top_voxel = (-1.5, -1.5, -1.5)
top_size = 2.

'## General Utilies

def pngsToSavedGif (delay:Int) (pngs:t=>Png) (outFileName:String) : Gif =
  unsafeIO \().
    withTempFiles \pngFiles.
      for i.
        writeFile pngFiles.i pngs.i
      shellOut $
        "convert" <> " -delay " <> show delay <> " " <>
        concat (for i. "png:" <> pngFiles.i <> " ") <>
        "gif:" <> outFileName <> ".gif"


def hue2rgb (p:Float) (q:Float) (t:Float) : Float = 
  t = t - floor t
  if t < (1.0/6.0)
    then p + (q - p) * 6.0 * t
    else if t < (1.0/2.0)
      then q
      else if t < (2.0/3.0)
        then p + (q - p) * (2.0/3.0 - t) * 6.0
        else p

def hslToRgb (h:Float) (s:Float) (l:Float) : (Fin 3)=>Float =
  if s == 0.0
    then [l, l, l] -- achromatic
    else
      q = select (l < 0.5) (l * (1.0 + s)) (l + s - l * s)
      p = 2.0 * l - q
      r = hue2rgb p q (h + 1.0/3.0)
      g = hue2rgb p q h
      b = hue2rgb p q (h - 1.0/3.0)
      [r, g, b]

def W8ToB' (x : Word8) : Bool = x > (IToW8 0)  -- Bug in prelude

def firstbit  (x:Word8) : Bool = W8ToB' $ x .&. (IToW8 1)
def secondbit (x:Word8) : Bool = W8ToB' $ x .&. (IToW8 2)
def thirdbit  (x:Word8) : Bool = W8ToB' $ x .&. (IToW8 4)

def intpow2 (power:Int) : Int = %shl 1 power
def last : n = ((size n) - 1)@n
def ixFraction (i:n) : Float = (IToF (ordinal i)) / (IToF ((size n) - 1))

'## Voxel utilities

def voxelWidth (lod: Int) : Float = 
  -- voxels divide up cube in (-1, 1)
  numDivisions = intpow2 $ lod
  top_size / (IToF numDivisions)

--:p voxelWidth (2)

def voxelToCentrePosition (lod: LoD) (voxel: Voxel) : Position =
  divSize = voxelWidth (ordinal lod)
  (xn, yn, zn) = voxel
  [0.5*divSize + xn,
   0.5*divSize + yn,
   0.5*divSize + zn]

--:p voxelToCentrePosition (1@LoD) (0.,0.,0.)

octantBackToFrontTable : Octant => Octant => Octant =
    intTable = [[ 0, 1, 2, 4, 3, 5, 6, 7 ],
                [ 1, 0, 3, 5, 2, 4, 7, 6 ],
                [ 2, 0, 3, 6, 1, 4, 7, 5 ],
                [ 3, 1, 2, 7, 0, 5, 6, 4 ],
                [ 4, 0, 5, 6, 1, 2, 7, 3 ],
                [ 5, 1, 4, 7, 0, 3, 6, 2 ],
                [ 6, 2, 4, 7, 0, 3, 5, 1 ],
                [ 7, 3, 5, 6, 1, 2, 4, 0 ]]
    for i j. (intTable.i.j@Octant)

def subVoxelPosToChildOctant (lod: LoD) (voxel: Voxel) (pos:Position) : Octant =
  [mid_x, mid_y, mid_z] = voxelToCentrePosition lod voxel
  [pos_x, pos_y, pos_z] = pos 
  bit1 = BToW8 $ pos_x > mid_x
  bit2 = BToW8 $ pos_y > mid_y
  bit3 = BToW8 $ pos_z > mid_z
  bits = W8ToI $ bit1 .|. (bit2 << 1) .|. (bit3 << 2)
  bits@Octant

'## Bounding box utilities

def voxeltoBB (lod:Int) (voxel: Voxel) : AABox =
  vwidth = voxelWidth lod
  (x, y, z) = voxel
  lower = [x, y, z]
  upper = [x + vwidth,
           y + vwidth,
           z + vwidth]
  (lower, upper)

--:p voxeltoBB (2) (0.,0.,0.) 

def rayAABBIntersection (ray:Ray) (box:AABox) : Bool =
  ([pos_x, pos_y, pos_z], [dir_x,  dir_y,  dir_z ]) = ray
  ([low_x, low_y, low_z], [high_x, high_y, high_z]) = box
  (tx1, tx2) = ((low_x - pos_x) / dir_x, (high_x - pos_x) / dir_x)
  (ty1, ty2) = ((low_y - pos_y) / dir_y, (high_y - pos_y) / dir_y)
  (tz1, tz2) = ((low_z - pos_z) / dir_z, (high_z - pos_z) / dir_z)
  txn = min tx1 tx2
  txf = max tx1 tx2
  tyn = min ty1 ty2
  tyf = max ty1 ty2
  tzn = min tz1 tz2
  tzf = max tz1 tz2
  tnear = max txn $ max tyn tzn
  tfar  = min txf $ min tyf tzf
  tfar > tnear && tfar > 0.0

--:p rayAABBIntersection (zero, [0.1, 0.1, 0.1]) (([1., 0., 0.], [2., 1., 1.]))

def intersectsVoxel (ray: Ray) (lod: Int) (voxel: Voxel) : Bool =
  box = voxeltoBB lod voxel
  rayAABBIntersection ray box

--:p intersectsVoxel (zero, [0.1, 0.1, 0.1]) (1) (1., 0., 0.)

'## Octtree intersection

def childOctantToSubVoxel (ray: Ray) (lod: Int) (oct: Octant) (voxel: Voxel) : (Voxel & Bool) =
    oo = IToW8 $ ordinal oct
    (x, y, z) = voxel
    vwidth = voxelWidth (lod + 1)
    subvoxel = (x + vwidth*(BToF $ firstbit oo),
                y + vwidth*(BToF $ secondbit oo),
                z + vwidth*(BToF $ thirdbit oo))
    (subvoxel, intersectsVoxel ray (lod + 1) subvoxel)

--:p childOctantToSubVoxel (zero, [0.1, 0.1, 0.1]) (0) (1@_) (0., 0., 0.)

def intersectedVoxels (ray: Ray) (lod: LoD) (childOcts: Octant=>Octant) (voxel: Voxel): List Voxel =
  emptyList = AsList _ []
  yieldState emptyList \ref. for i:(Fin 8).
    subvoxel_pair = childOctantToSubVoxel ray (ordinal lod) childOcts.i voxel
    if (snd subvoxel_pair) then
      ref := concat [ (get ref), toList [(fst subvoxel_pair)] ]

--:p intersectedVoxels (zero, [0.1, 0.1, 0.1]) (0@(LoD)) [0@_, 1@_, 2@_, 4@_, 3@_, 5@_, 6@_, 7@_] (0., 0., 0.)

def orderedChildren (lod: LoD) (ray:Ray) (voxel: Voxel) : Octant=>Octant =
  (pos, dir) = ray
  oct = subVoxelPosToChildOctant lod voxel pos
  octantBackToFrontTable oct

def subdivide (ray: Ray) (lod: LoD) (voxelList: List Voxel) : List Voxel =
    (AsList _ voxels) = voxelList
    yieldAccum (ListMonoid Voxel) \list.
        for i.
          childOcts = orderedChildren lod ray voxels.i
          intersected = intersectedVoxels ray lod childOcts voxels.i
          list += intersected

def rayTraceOctree (ray: Ray) : LoD => List Voxel =
    init = AsList 1 [top_voxel]
    fst $ runState init \ref. for lod:LoD.
        vlevel = get ref
        ref := subdivide ray lod vlevel
        vlevel

' ### Generic Helper Functions
Some of these should probably go in prelude.

-- def Vec (n:Int) : Type = Fin n => Float
def Mat (n:Int) (m:Int) : Type = Fin n => Fin m => Float

def relu (x:Float) : Float = max x 0.0
def length    (x: d=>Float) : Float = sqrt $ sum for i. sq x.i
-- TODO: make a newtype for normal vectors
def normalize (x: d=>Float) : d=>Float = x / (length x)
def directionAndLength (x: d=>Float) : (d=>Float & Float) =
  l = length x
  (x / (length x), l)

def randuniform (lower:Float) (upper:Float) (k:Key) : Float =
  lower + (rand k) * (upper - lower)

def sampleAveraged [VSpace a] (sample:Key -> a) (n:Int) (k:Key) : a =
  yieldState zero \total.
    for i:(Fin n).
      total := get total + sample (ixkey k i) / IToF n

def positiveProjection (x:n=>Float) (y:n=>Float) : Bool = dot x y > 0.0

' ### 3D Helper Functions

def cross (a:Vec 3) (b:Vec 3) : Vec 3 =
  [a1, a2, a3] = a
  [b1, b2, b3] = b
  [a2 * b3 - a3 * b2, a3 * b1 - a1 * b3, a1 * b2 - a2 * b1]

-- TODO: Use `data Color = Red | Green | Blue` and ADTs for index sets
data Image =
 MkImage height:Int width:Int (Fin height => Fin width => Color)

xHat : Vec 3 = [1., 0., 0.]
yHat : Vec 3 = [0., 1., 0.]
zHat : Vec 3 = [0., 0., 1.]

Angle = Float  -- angle in radians

def rotateX (p:Vec 3) (angle:Angle) : Vec 3 =
  c = cos angle
  s = sin angle
  [px, py, pz] = p
  [px, c*py - s*pz, s*py + c*pz]

def rotateY (p:Vec 3) (angle:Angle) : Vec 3 =
  c = cos angle
  s = sin angle
  [px, py, pz] = p
  [c*px + s*pz, py, - s*px+ c*pz]

def rotateZ (p:Vec 3) (angle:Angle) : Vec 3 =
  c = cos angle
  s = sin angle
  [px, py, pz] = p
  [c*px - s*py, s*px+c*py, pz]

def sampleCosineWeightedHemisphere (normal: Vec 3) (k:Key) : Vec 3 =
  [k1, k2] = splitKey k
  u1 = rand k1
  u2 = rand k2
  uu = normalize $ cross normal [0.0, 1.1, 1.1]
  vv = cross uu normal
  ra = sqrt u2
  rx = ra * cos (2.0 * pi * u1)
  ry = ra * sin (2.0 * pi * u1)
  rz = sqrt (1.0 - u2)
  rr = (rx .* uu) + (ry .* vv) + (rz .* normal)
  normalize rr

' ### Raytracer

BlockHalfWidths = Vec 3
Radius = Float
Radiance = Color

data ObjectGeom =
  Wall Direction Distance
  Block Position BlockHalfWidths Angle
  Sphere Position Radius

data Surface =
  Matte Color
  Mirror

OrientedSurface = (Direction & Surface)

data Object =
  PassiveObject ObjectGeom Surface
  -- position, half-width, intensity (assumed to point down)
  Light Position Float Radiance

Filter   = Color

-- TODO: use a record
-- num samples, num bounces, share seed?
Params = { numSamples : Int
         & maxBounces : Int
         & shareSeed  : Bool }

-- TODO: use a list instead, once they work
data Scene n:Type = MkScene (n=>Object)

def sampleReflection ((nor, surf):OrientedSurface) ((pos, dir):Ray) (k:Key) : Ray =
  newDir = case surf of
    Matte _ -> sampleCosineWeightedHemisphere nor k
    -- TODO: surely there's some change-of-solid-angle correction we need to
    -- consider when reflecting off a curved surface.
    Mirror  -> dir - (2.0 * dot dir nor) .* nor
  (pos, newDir)

def probReflection ((nor, surf):OrientedSurface) (_:Ray) ((_, outRayDir):Ray) : Float =
  case surf of
    Matte _ -> relu $ dot nor outRayDir
    Mirror  -> 0.0  -- TODO: this should be a delta function of some sort

def applyFilter (filter:Filter) (radiance:Radiance) : Radiance =
  for i. filter.i * radiance.i

def surfaceFilter (filter:Filter) (surf:Surface) : Filter =
  case surf of
    Matte color -> for i. filter.i * color.i
    Mirror      -> filter

def sdObject (pos:Position) (obj:Object) : Distance =
  case obj of
    PassiveObject geom _ -> case geom of
      Wall nor d -> d + dot nor pos
      Block blockPos halfWidths angle ->
        pos' = rotateY (pos - blockPos) angle
        length $ for i. max ((abs pos'.i) - halfWidths.i) 0.0
      Sphere spherePos r ->
        pos' = pos - spherePos
        max (length pos' - r) 0.0
    Light squarePos hw _ ->
      pos' = pos - squarePos
      halfWidths = [hw, 0.01, hw]
      length $ for i. max ((abs pos'.i) - halfWidths.i) 0.0

def sdScene (scene:Scene n) (pos:Position) : (Object & Distance) =
  (MkScene objs) = scene
  (i, d) = minimumBy snd $ for i. (i, sdObject pos objs.i)
  (objs.i, d)

def calcNormal (obj:Object) (pos:Position) : Direction =
  normalize (grad (flip sdObject obj) pos)

data RayMarchResult =
  -- incident ray, surface normal, surface properties
  HitObj Ray OrientedSurface
  HitLight Radiance
  -- Could refine with failure reason (beyond horizon, failed to converge etc)
  HitNothing

def raymarch (scene:Scene n) (ray:Ray) : RayMarchResult =
  maxIters = 100
  tol = 0.01
  startLength = 10.0 * tol  -- trying to escape the current surface
  (rayOrigin, rayDir) = ray
  withState (10.0 * tol) \rayLength.
    boundedIter maxIters HitNothing \_.
      rayPos = rayOrigin + get rayLength .* rayDir
      (obj, d) = sdScene scene $ rayPos
      -- 0.9 ensures we come close to the surface but don't touch it
      rayLength := get rayLength + 0.9 * d
      case d < tol of
        False -> Continue
        True ->
          surfNorm = calcNormal obj rayPos
          case positiveProjection rayDir surfNorm of
            True ->
              -- Oops, we didn't escape the surface we're leaving..
              -- (Is there a more standard way to do this?)
              Continue
            False ->
              -- We made it!
              Done $ case obj of
                PassiveObject _ surf -> HitObj (rayPos, rayDir) (surfNorm, surf)
                Light _ _ radiance   -> HitLight radiance

def rayDirectRadiance (scene:Scene n) (ray:Ray) : Radiance =
  case raymarch scene ray of
    HitLight intensity -> intensity
    HitNothing -> zero
    HitObj _ _ -> zero

def sampleSquare (hw:Float) (k:Key) : Position =
 [kx, kz] = splitKey k
 x = randuniform (- hw) hw kx
 z = randuniform (- hw) hw kz
 [x, 0.0, z]

def sampleLightRadiance
      (scene:Scene n) (osurf:OrientedSurface) (inRay:Ray) (k:Key) : Radiance =
  (surfNor, surf) = osurf
  (rayPos, _) = inRay
  (MkScene objs) = scene
  yieldAccum (AddMonoid Float) \radiance.
    for i. case objs.i of
      PassiveObject _ _ -> ()
      Light lightPos hw _ ->
        (dirToLight, distToLight) = directionAndLength $
                                      lightPos + sampleSquare hw k - rayPos
        if positiveProjection dirToLight surfNor then
          -- light on this far side of current surface
          fracSolidAngle = (relu $ dot dirToLight yHat) * sq hw / (pi * sq distToLight)
          outRay = (rayPos, dirToLight)
          coeff = fracSolidAngle * probReflection osurf inRay outRay
          radiance += coeff .* rayDirectRadiance scene outRay

def trace (params:Params) (scene:Scene n) (initRay:Ray) (k:Key) : Color =
  noFilter = [1.0, 1.0, 1.0]
  yieldAccum (AddMonoid Float) \radiance.
    runState  noFilter \filter.
     runState initRay  \ray.
      boundedIter (getAt #maxBounces params) () \i.
        case raymarch scene $ get ray of
          HitNothing -> Done ()
          HitLight intensity ->
            if i == 0 then radiance += intensity   -- TODO: scale etc
            Done ()
          HitObj incidentRay osurf ->
            [k1, k2] = splitKey $ hash k i
            lightRadiance = sampleLightRadiance scene osurf incidentRay k1
            ray    := sampleReflection osurf incidentRay k2
            filter := surfaceFilter (get filter) (snd osurf)
            radiance += applyFilter (get filter) lightRadiance
            Continue

-- Assumes we're looking towards -z.
Camera =
  { numPix     : Int
  & pos        : Position  -- pinhole position
  & halfWidth  : Float     -- sensor half-width
  & sensorDist : Float }   -- pinhole-sensor distance

-- TODO: might be better with an anonymous dependent pair for the result
def cameraRays (n:Int) (camera:Camera) : Fin n => Fin n => (Key -> Ray) =
  -- images indexed from top-left
  halfWidth = getAt #halfWidth camera
  pixHalfWidth = halfWidth / IToF n
  ys = reverse $ linspace (Fin n) (neg halfWidth) halfWidth
  xs =           linspace (Fin n) (neg halfWidth) halfWidth
  for i j. \key.
    [kx, ky] = splitKey key
    x = xs.j + randuniform (-pixHalfWidth) pixHalfWidth kx
    y = ys.i + randuniform (-pixHalfWidth) pixHalfWidth ky
    (getAt #pos camera, normalize [x, y, neg (getAt #sensorDist camera)])

def takePicture (params:Params) (scene:Scene m) (camera:Camera) : Image =
  n = getAt #numPix camera
  rays = cameraRays n camera
  rootKey = newKey 0
  image = for i j.
    pixKey = if getAt #shareSeed params
      then rootKey
      else ixkey (ixkey rootKey i) j
    sampleRayColor : Key -> Color =  \k.
      [k1, k2] = splitKey k
      trace params scene (rays.i.j k1) k2
    sampleAveraged sampleRayColor (getAt #numSamples params) pixKey
  MkImage _ _ $ image / mean (for (i,j,k). image.i.j.k)

' ### Define the scene and render it

lightColor = [0.2, 0.2, 0.2]
leftWallColor  = 1.5 .* [0.611, 0.0555, 0.062]
rightWallColor = 1.5 .* [0.117, 0.4125, 0.115]
whiteWallColor = [255.0, 239.0, 196.0] / 255.0
blockColor     = [200.0, 200.0, 255.0] / 255.0

objs1 = [ Light (1.9 .* yHat) 0.5 lightColor
    , PassiveObject (Wall      xHat  2.0) (Matte whiteWallColor)
    , PassiveObject (Wall (neg xHat) 2.0) (Matte whiteWallColor)
    , PassiveObject (Wall      yHat  2.0) (Matte whiteWallColor)
    , PassiveObject (Wall (neg yHat) 2.0) (Matte whiteWallColor)
    , PassiveObject (Wall      zHat  2.0) (Matte whiteWallColor)
    -- , PassiveObject (Block  [ 1.0, -1.6,  1.2] [0.6, 0.8, 0.6] 0.5) (Matte blockColor)
    -- , PassiveObject (Sphere [-1.0, -1.2,  0.2] 0.8) (Matte (0.7.* whiteWallColor))
    -- , PassiveObject (Sphere [ 2.0,  2.0, -2.0] 1.5) (Mirror)
    ]

allvoxels = rayTraceOctree ([-1.5, -1.5, -1.5], [1.0, 1.0, 1.0])
--:p allvoxels

show_lod = 5@(LoD)
lodvoxels = allvoxels.show_lod 
--:p lodvoxels
(AsList _ vl) = lodvoxels

--:p vl

objs3 = for i.
  cpos = voxelToCentrePosition show_lod vl.i
  vw = 0.5 * voxelWidth (ordinal show_lod)
  PassiveObject (Block cpos [vw, vw, vw] 0.0) (Matte blockColor)

vw = 0.1
cpos = [0.,1.,0.]
cpos2 = [-2., -2., 0.]
cpos3 = [0.0, 0.0, -2.0]
testobj1 = for i:(Fin 1). PassiveObject (Block cpos [vw, vw, vw] 0.0) (Matte blockColor)
testobj2 = for i:(Fin 1). PassiveObject (Block cpos2 [vw, vw, vw] 0.0) (Matte blockColor)
testobj3 = for i:(Fin 1). PassiveObject (Block cpos3 [vw, vw, vw] 0.0) (Matte blockColor)
testobj4 = for i:(Fin 1). PassiveObject (Sphere [1.0,1.0,1.0] 0.5) (Matte blockColor)

--combl = (AsList _ objs1) <> (AsList _ testobj1) <> (AsList _ testobj2) <> (AsList _ testobj3)
combl = (AsList _ objs1) <> (AsList _ objs3) --<> (AsList _ testobj4)
(AsList _ cot) = combl
theScene = MkScene cot

defaultParams = { numSamples = 1
                , maxBounces = 2
                , shareSeed  = True }

defaultCamera = { numPix     = 400
                , pos        = 10.0 .* zHat
                , halfWidth  = 0.3
                , sensorDist = 1.0 }

-- We change to a small num pix here to reduce the compute needed for tests
params = defaultParams
camera = if dex_test_mode ()
           then defaultCamera |> setAt #numPix 10
           else defaultCamera

%time
(MkImage _ _ image) = takePicture params theScene camera
:html imshow image


-- :html imseqshow xmovieflat
-- pngsToSavedGif 1 (map imgToPng xmovieflat) "gwg"


'## Smoothed-particle hydrodynamics
Ported from [this](https://github.com/pmocz/sph-python) implementation by Philip Mocz.

D = 3
def Vec (d:Int) : Type = (Fin d)=>Float

def map' (f:a->{|eff} b) (xs:n=>m=>a) : {|eff} (n=>m=>b) = for i j. f xs.i.j
def exp' (h:Float) (x:Float) : Float = exp $ -1. * sq x / sq h
def dist (xs:n=>m=>Vec D) : n=>m=>Float = for i j. sqrt $ vdot xs.i.j xs.i.j

-- gaussian smoothing kernel
def GSK (xs:n=>m=>Vec D) (h:Float) : n=>m=>Float =
  pow (1.0 / (h * sqrt pi)) 3. .* (map' (exp' h) (dist xs))

def gradGSK (xs:n=>m=>Vec D) (h:Float) : (n=>m=>Vec D) =
  scale = (-2. / (pow h 5. * sqrt (pow pi 3.))) .* (map' (exp' h) (dist xs))
  for i j k. scale.i.j * xs.i.j.k

def getPairwiseSeparations (xs:n=>Vec D) (ys:m=>Vec D) : n=>m=>Vec D =
  for i j. xs.i - ys.j

def getDensity (samples:n=>Vec D) (pos:m=>Vec D) 
               (m:Float) (h:Float) : n=>Float =
  xs = m .* GSK (getPairwiseSeparations samples pos) h
  for i. sum $ xs.i

def getPressure (rho:n=>Float) (k:Float) (pIdx:Float) : n=>Float =
  k .* (map (\d. pow d (1.+1./pIdx)) rho)

def getAcc (pos:n=>Vec D) (vel:n=>Vec D)
           (m:Float) (h:Float) (k:Float) (pIdx:Float) 
           (lmbda:Float) (nu:Float) : n=>Vec D =
  rho = getDensity pos pos m h
  p = getPressure rho k pIdx
  xs = getPairwiseSeparations pos pos
  del = gradGSK xs h
  p' = m .* (for i. for j. p.i / sq rho.i + p.j / sq rho.j)
  a = for i. 
    row = for j. [p'.i.j * del.i.j.(0@_),
                  p'.i.j * del.i.j.(1@_),
                  p'.i.j * del.i.j.(2@_)]
    -1. .* (sum row)

  -- add external potential force and viscosity to acceleration
  a - lmbda .* pos - nu .* vel

'### Simulation

'Parameters

Times = Fin 200
n = 2000       -- # particles
dt = 0.04     -- timestep
mStar = 2.    -- star mass
rStar = 0.75  -- star radius
h = 0.1       -- smoothing length
k = 0.1       -- equation of state constant
pIdx = 1.        -- polytropic index
nu = 1.       -- damping

depOnI1 = 3.323350970447843
depOnI2 = 1.
lmbda = (2.)*k*(1. + pIdx)*(pow pi (-3./(2. * pIdx)))*(pow (mStar*depOnI1/(pow rStar 3.)/depOnI2) (1./pIdx))/(pow rStar 2.)
m = mStar/(IToF n)   -- single particle mass

Position = Vec D
Velocity = Vec D
Acceleration = Vec D
Mass = Float
Density = Float

data BodyState = 
    MkBodyState Mass Position Velocity Acceleration Density

BodyInd = Fin n

[k1,k2] = splitKey (newKey 0)
initPos:BodyInd=>Position = 1.0e-1 .* for i j. rand $ ixkey2 k1 i j
initVel:BodyInd=>Velocity = zero
initAcc:BodyInd=>Acceleration = getAcc initPos initVel m h k pIdx lmbda nu
initDen:BodyInd=>Density = getDensity initPos initPos m h
initState:BodyInd=>BodyState = for i. 
  MkBodyState m initPos.i initVel.i initAcc.i initDen.i

-- leapfrog integrator
def update (bodystates:n=>BodyState) (dt:Float) : n=>BodyState =
  -- Updates all the body states.
  bodystates' = for i.
    (MkBodyState mass pos vel acc den) = bodystates.i
    vel' = vel + dt/2. .* acc
    pos' = pos + dt .* vel'
    MkBodyState mass pos' vel' acc den
  totalPos = for i.
    (MkBodyState mass pos vel acc den) = bodystates'.i
    pos
  totalVel = for i.
    (MkBodyState mass pos vel acc den) = bodystates'.i
    vel
  updatedAcc = getAcc totalPos totalVel m h k pIdx lmbda nu
  updatedDen = getDensity totalPos totalPos m h
  for i.
    (MkBodyState mass pos vel acc den) = bodystates'.i
    vel' = vel + dt/2. .* updatedAcc.i
    MkBodyState mass pos vel' updatedAcc.i updatedDen.i

def step (_: Times) (bodies:n=>BodyState) : n=>BodyState = 
  update bodies dt

-- Versions of scan that explicity take the index set n.
def scan'' (init:a) (n:Type) (body:n->a->(a&b)) : (a & n=>b) =
  swap $ runState init \s. for i.
    c = get s
    (c', y) = body i c
    s := c'
    y

def scan''' (init:a) (n:Type) (body:n->a->a) : n=>a =
  snd $ scan'' init n \i x. dup (body i x)

%time
history = scan''' initState Times step

:t history

' #### Gif

def hue2rgb (p:Float) (q:Float) (t:Float) : Float = 
  t = t - floor t
  if t < (1.0/6.0)
    then p + (q - p) * 6.0 * t
    else if t < (1.0/2.0)
      then q
      else if t < (2.0/3.0)
        then p + (q - p) * (2.0/3.0 - t) * 6.0
        else p

def hslToRgb (h:Float) (s:Float) (l:Float) : (Fin 3)=>Float =
  if s == 0.0
    then [l, l, l] -- achromatic
    else
      q = select (l < 0.5) (l * (1.0 + s)) (l + s - l * s)
      p = 2.0 * l - q
      r = hue2rgb p q (h + 1.0/3.0)
      g = hue2rgb p q h
      b = hue2rgb p q (h - 1.0/3.0)
      [r, g, b]

def pathImgs (hist:t=>n=>BodyState) : t=>h=>w=>(Fin 3)=>Float =
    size_h = IToF $ size h
    size_w = IToF $ size w
    max_d = 1.
    yieldAccum (AddMonoid Float) \imgs.
      for tt i.
        (MkBodyState m p _ _ d) = hist.tt.i
        [x, y, _] = p
        wx' = FToI $ round $ clip (0.0,1.0) ((x+1.)/3.) * (size_h-1.)
        hy' = FToI $ round $ clip (0.0,1.0) ((y+1.)/3.) * (size_w-1.)
        wx = (wx'@_)
        hy = (hy'@_)
        c = d/max_d
        imgs!tt!hy!wx += zero + hslToRgb c 1.0 0.5
      ()

-- Change me! resolution
imgs : Times=>(Fin 400)=>(Fin 400)=>(Fin 3)=>Float = pathImgs history

import png

-- :html imgToHtml $ pngsToGif 5 $ map imgToPng imgs

def pngsToSavedGif (delay:Int) (pngs:t=>Png) (outFileName:String) : Gif =
  unsafeIO \().
    withTempFiles \pngFiles.
      for i.
        writeFile pngFiles.i pngs.i
      shellOut $
        "convert" <> " -delay " <> show delay <> " " <>
        concat (for i. "png:" <> pngFiles.i <> " ") <>
        "gif:" <> outFileName <> ".gif"

%time
pngs = map imgToPng imgs


%time
pngsToSavedGif 5 pngs "sph"



'## Fast multiquadrics 
Laurent series expansion for the fast summation of radial basis functions,
based on this [tutorial](https://math.nyu.edu/~greengar/shortcourse_fmm.pdf).

def intlog2 (x:Int) : Int =
  yieldState (-1) \ansRef.
    runState 1 \cmpRef.
      while do
        if x >= (get cmpRef)
          then 
            ansRef := (get ansRef) + 1
            cmpRef := %shl (get cmpRef) 1
            True
          else
            False

def intpow2 (power:Int) : Int = %shl 1 power

c = 0.1
n = 64
m = intlog2 n -- # levels
num_panels = intpow2 m

-- multiquadric radial basis function, naive summation
def rbf (x: Float) (sources: (Fin n)=>Float) (weights: (Fin n)=>Float) : Float = 
    sum for i:(Fin n). weights.i * sqrt (sq (x - sources.i) + sq c)

'Far-field expansions

-- root panel: [0, 1]
-- there is a tradeoff between 
    -- precision (error e) and 
    -- efficiency (number of truncated laurent series terms p)
-- based on https://www.sciencedirect.com/science/article/pii/089812219290167G,
-- a good choice is p = (log e) / (log a), a = (sqrt 2)/3

e = 0.1
a = (sqrt 2.)/3.
p = log2 e / log2 a
p

sources = randVec n rand (newKey 0)
weights = randVec n rand (newKey 1)

'Setup

-- heuristically for now, an array representation for the tree
Tree = (Fin num_panels) => List Int 
-- todo: make an index set that starts from 1 instead of 0
panels: Tree = for i. AsList _ []

-- wip
def sort (panels: Tree) (sources: (Fin n)=>Float) (root: (Float & Float)): Tree =
    yieldState panels \ref.
        for i:(Fin num_panels). 
            ref!i := AsList _ [2]

'Evaluation

-- key idea: separate the involvement of the evaluation point and source points in the summation
-- hierarchy subdivision is probably not necessary here. The point is to differentiate nearest from far.
x = -- evaluation point

%time
rbf x 

%time
rbf x sources weights

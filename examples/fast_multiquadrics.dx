'## Fast multiquadrics 
Laurent series expansion for the fast summation of radial basis functions,
based on this [tutorial](https://math.nyu.edu/~greengar/shortcourse_fmm.pdf).

def intlog2 (x:Int) : Int =
  yieldState (-1) \ansRef.
    runState 1 \cmpRef.
      while do
        if x >= (get cmpRef)
          then 
            ansRef := (get ansRef) + 1
            cmpRef := %shl (get cmpRef) 1
            True
          else
            False

def intpow2 (power:Int) : Int = %shl 1 power

c = 0.1
n = 64
m = intlog2 n -- # levels
num_leaves = intpow2 m
l = 1. -- root panel: [0, 1]
w = l/num_leaves

-- multiquadric radial basis function, naive summation
def rbf (x: Float) (sources: (Fin n)=>Float) (weights: (Fin n)=>Float) : Float = 
    sum for i:(Fin n). weights.i * sqrt (sq (x - sources.i) + sq c)

'Far-field expansions

-- there is a tradeoff between 
    -- precision (error e) and 
    -- efficiency (number of truncated laurent series terms p)
-- based on https://www.sciencedirect.com/science/article/pii/089812219290167G,
-- a good choice is p = (log e) / (log a), a = (sqrt 2)/3

e = 0.01
a = (sqrt 2.)/3.
p = log2 e / log2 a
p
p_int = 6

sources = randVec n rand (newKey 0)
weights = randVec n rand (newKey 1)

-- todo: a bit inconvenient to adjust sum_coeff and laurent_approx every time p_int is changed
def sum_coeff (s: (Fin a) => Float) : (Fin 6) => Float =

    term2 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t += s.i 
    term4 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t += 0.5 *c*c*s.i
    term5 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t+= 0.125 * (4. * s.i*s.i*c*c - c*c*c*c)     
    term6 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t+= 0.125 * (4. * s.i*s.i*s.i*c*c - 3. * s.i*c*c*c*c)
    
    [IToF a, term2, (IToF a) * 0.5 * (sq c), term4, term5, term6]

def laurent_approx (x: Float) (coeff: (Fin 6) => Float) : Float =
    coeff.(0@_)*x - coeff.(1@_) + coeff.(2@_)/x + coeff.(3@_)/(x*x) + coeff.(4@_)/(x*x*x) + coeff.(5@_)/(x*x*x*x)

'Setup

-- an array representation for the tree leaves. it's not necessary to have the entire tree.
Tree = (Fin num_leaves) => List Float\
panels: Tree = for i. AsList _ []

-- stateful sort for now.
def sort (panels: Tree) (sources: (Fin n)=>Float) (root: (Float & Float)): Tree =
    yieldState panels \ref.
        for i:(Fin n). 
            s = sources.i
            final_range = yieldState root \range.
                for i:(Fin m).
                    middle = ((fst (get range)) + (snd (get range))) / 2.
                    range := case s > middle of 
                        True -> (middle, snd (get range))
                        False -> (fst (get range), middle)
            index = FToI $ (fst final_range)/w
            ref!index := ref.index <> AsList _ [s]



'Evaluation

-- key idea: separate the involvement of the evaluation point and source points in the summation
-- hierarchy subdivision is probably not necessary here. The point is to differentiate nearest from far.
x = 0.1 -- evaluation point

--%time
--rbf x 

%time
rbf x sources weights

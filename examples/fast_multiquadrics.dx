'## Fast multiquadrics 
Laurent series expansion for the fast summation of radial basis functions,
based on this [tutorial](https://math.nyu.edu/~greengar/shortcourse_fmm.pdf).

def intlog2 (x:Int) : Int =
  yieldState (-1) \ansRef.
    runState 1 \cmpRef.
      while do
        if x >= (get cmpRef)
          then 
            ansRef := (get ansRef) + 1
            cmpRef := %shl (get cmpRef) 1
            True
          else
            False

def intpow2 (power:Int) : Int = %shl 1 power

c = 0.1
n = 64
m = intlog2 n -- # levels
num_panels = intpow2 m

-- multiquadric radial basis function, naive summation
def rbf (x: Float) (sources: (Fin n)=>Float) (weights: (Fin n)=>Float) : Float = 
    sum for i:(Fin n). weights.i * sqrt (sq (x - sources.i) + sq c)

'Far-field expansions

-- root panel: [0, 1]
-- there is a tradeoff between 
    -- precision (error e) and 
    -- efficiency (number of truncated laurent series terms p)
-- based on https://www.sciencedirect.com/science/article/pii/089812219290167G,
-- a good choice is p = (log e) / (log a), a = (sqrt 2)/3

e = 0.01
a = (sqrt 2.)/3.
p = log2 e / log2 a
p
p_int = 6

sources = randVec n rand (newKey 0)
weights = randVec n rand (newKey 1)

-- todo: a bit inconvenient to adjust sum_coeff and laurent_approx every time p_int is changed
def sum_coeff (s: (Fin a) => Float) : (Fin 6) => Float =

    term2 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t += s.i 
    term4 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t += 0.5 *c*c*s.i
    term5 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t+= 0.125 * (4. * s.i*s.i*c*c - c*c*c*c)     
    term6 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t+= 0.125 * (4. * s.i*s.i*s.i*c*c - 3. * s.i*c*c*c*c)
    
    [IToF a, term2, (IToF a) * 0.5 * (sq c), term4, term5, term6]

def laurent_approx (x: Float) (coeff: (Fin 6) => Float) : Float =
    coeff.(0@_)*x - coeff.(1@_) + coeff.(2@_)/x + coeff.(3@_)/(x*x) + coeff.(4@_)/(x*x*x) + coeff.(5@_)/(x*x*x*x)

'Setup

-- heuristically for now, an array representation for the tree
Tree = (Fin num_panels) => List Int 
-- todo: make an index set that starts from 1 instead of 0
panels: Tree = for i. AsList _ []

-- wip
def sort (panels: Tree) (sources: (Fin n)=>Float) (root: (Float & Float)): Tree =
    yieldState panels \ref.
        for i:(Fin num_panels). 
            ref!i := AsList _ [2]

'Evaluation

-- key idea: separate the involvement of the evaluation point and source points in the summation
-- hierarchy subdivision is probably not necessary here. The point is to differentiate nearest from far.
x = 0.1 -- evaluation point

--%time
--rbf x 

%time
rbf x sources weights

'## Fast multiquadrics 
Laurent series expansion for the fast summation of radial basis functions,
based on this [tutorial](https://math.nyu.edu/~greengar/shortcourse_fmm.pdf).

def intlog2 (x:Int) : Int =
  yieldState (-1) \ansRef.
    runState 1 \cmpRef.
      while do
        if x >= (get cmpRef)
          then 
            ansRef := (get ansRef) + 1
            cmpRef := %shl (get cmpRef) 1
            True
          else
            False

def intpow2 (power:Int) : Int = %shl 1 power

c = 0.5
n = 64
m = intlog2 n -- # levels
num_leaves = intpow2 (m-1)
num_panels = sum $ withState num_leaves \num. for i:(Fin m). 
    num := intpow2 (ordinal i)
    get num
l = 1. -- root panel: [0, 1]
w = l/(IToF num_leaves)

-- multiquadric radial basis function, naive summation
def rbf (x: Float) (queries: (Fin n)=>(Float&Float)) : Float = 
    sum for i:(Fin n). (fst queries.i) * sqrt (sq (x - (snd queries.i)) + sq c)

'Far-field expansions

-- there is a tradeoff between 
    -- precision (error e) and 
    -- efficiency (number of truncated laurent series terms p)
-- based on https://www.sciencedirect.com/science/article/pii/089812219290167G,
-- a good choice is p = (log e) / (log a), a = (sqrt 2)/3

e = 0.01
a = (sqrt 2.)/3.
p = log2 e / log2 a
p
p_int = 6

sources = randVec n rand (newKey 0)
weights = randVec n rand (newKey 1)
queries = for i:(Fin n). (sources.i, weights.i)

-- todo: a bit inconvenient to adjust sum_coeff and laurent_approx every time p_int is changed
def sum_coeff (q: (Fin a) => (Float&Float)) : (Fin 6) => Float =

    term2 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t += (fst q.i)
    term4 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t += 0.5 *c*c*(fst q.i)
    term5 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t+= 0.125 * (4. * (fst q.i)*(fst q.i)*c*c - c*c*c*c)     
    term6 = yieldAccum (AddMonoid Float) \t.
        for_ i:(Fin a). t+= 0.125 * (4. * (fst q.i)*(fst q.i)*(fst q.i)*c*c - 3. * (fst q.i)*c*c*c*c)
    
    [IToF a, term2, (IToF a) * 0.5 * (sq c), term4, term5, term6]

def laurent_approx (x: Float) (coeff: (Fin 6) => Float) : Float =
    coeff.(0@_)*x - coeff.(1@_) + coeff.(2@_)/x + coeff.(3@_)/(x*x) + coeff.(4@_)/(x*x*x) + coeff.(5@_)/(x*x*x*x)

'Setup

-- an array representation for the tree.
Tree = (Fin num_panels) => (Fin 6) => Float
Leaves = (Fin num_leaves) => List (Float & Float)

def sort (queries: (Fin n)=>(Float&Float)) (root: (Float & Float)): Leaves =
    init: Leaves = for i. AsList _ []
    yieldState init \ref.
        for i:(Fin n). 
            s = queries.i
            final_range = yieldState root \range.
                for i:(Fin m).
                    middle = ((fst (get range)) + (snd (get range))) / 2.
                    range := case (fst s) > middle of 
                        True -> (middle, snd (get range))
                        False -> (fst (get range), middle)
            index = FToI $ (fst final_range)/w
            ref!(index@_) := (get ref).(index@_) <> AsList _ [s]

-- a bit of dynamic programming
def expand (leaves: Leaves) : Tree =
    panels: Tree = for i. for j. 0.
    yieldState panels \ref.
        init = num_panels - 1
        next_init = yieldState init \index.
            for_ i:(Fin num_leaves).
                i' = num_leaves - (ordinal i) - 1
                (AsList numq q) = leaves.(i'@_)
                if numq /= 0 then
                    q' = for j:(Fin numq). q.(unsafeFromOrdinal _ (ordinal j))
                    ref!((get index)@_) := sum_coeff q'
                index := (get index) - 1
        yieldState next_init \index.
            num_ances = num_panels - num_leaves
            for_ i:(Fin num_ances).
                left = (get index) * 2
                right = (get index) * 2 + 1
                ref!((get index)@_) := (get ref).(left@_) + (get ref).(right@_)
                index := (get index) - 1

sorted = sort queries (0., 1.)
expanded = expand sorted

'Evaluation

-- key idea: separate the involvement of the evaluation point and source points in the summation
x = 0.1 -- evaluation point

--%time
--rbf x 

%time
rbf x queries

'### Arithmetic coding
A finite-precision variant based on [this](https://web.stanford.edu/class/ee398a/handouts/papers/WittenACM87ArithmCoding.pdf) paper by Ian H. Witten et al.

Alphabet = Fin 26
Interval = (Int&Int)
Code = (Int&Int&Int)
maxBits = 7
maxInt = intpow2 maxBits
half = idiv maxInt 2
fstQuarter = idiv half 2
thdQuarter = fstQuarter * 3

def charToIdx (c: Word8) : Int = W8ToI c - W8ToI 'a'
def idxToChar (i: Int) : Word8 = IToW8 (i + (W8ToI 'a'))
def intToBin (i: Int) : List Word8 = "WIP"

'Statistical modelling

def normalize (freq: Int) (l: Int) (w: Int) : Int = FToI $ IToF freq / IToF l * IToF w

def getCumFreq (fs: Alphabet=>Int) : Alphabet=>Int =
  withState zero \total.
    for i. if fs.i /= zero
      then
        newTotal = get total + fs.i
        total := newTotal
        newTotal
      else zero

def getIntervals (xs: Alphabet=>Int) : Alphabet=>Interval =
  withState (0,0) \ref.
    for i. if xs.i /= zero
      then
        ref := ((snd (get ref)), xs.i)
        get ref
      else (0,0)

def getFrequency (str: (Fin l)=>Word8) : Alphabet=>Int =
  a: Alphabet => Int = zero
  yieldState a \ref. for i. 
    i' = (charToIdx str.i)@_
    ref!i' := (get ref).i' + 1

def model (str: (Fin l)=>Word8) : Alphabet=>(Interval->Interval) =
  freq = getFrequency str
  cumFreq = getCumFreq freq
  inFreq = getIntervals cumFreq
  for i.
    case inFreq.i == (0,0) of
      True -> id
      False ->
        (fLow, fHigh) = inFreq.i
        \(low, high).
          w = high-low+1
          low' = low + normalize fLow l w
          high' = low-1 + normalize fHigh l w
          (low', high')

'Coding via integer arithmetic

def enqueue (bit: Int) ((code, numBits, tally): Code) : Code =
  half = intpow2 numBits
  case bit==1 of 
    True -> (%or code half, numBits+tally+1, 0)
    False -> 
      (code', numBits') = yieldState (code, numBits+1) \ref. for i:(Fin tally).
        (code', numBits') = get ref
        half' = intpow2 numBits'
        ref := (%or code' half', numBits'+1)
      (code', numBits', 0)

def dequeue ((code, numBits, tally): Code) : (Code&Int) = 
  ((%shr code 1, numBits-1, tally), %and 1 code)

-- tests
enqueue 1 (2,5,0)
> (34, (6, 0))
dequeue (34,6,0)
> ((17, (5, 0)), 0)
dequeue (17,5,0)
> ((8, (4, 0)), 1)

def intervalRef (ref: Ref h (a&b)) : Ref h a = %fstRef ref
def codeRef (ref: Ref h (a&b)) : Ref h b = %sndRef ref
def tallyRef (ref: Ref h (a&(b&c&d))) : Ref h d = %sndRef (%sndRef (%sndRef ref))

def getInterval (ref: Ref h (a&b)) : {State h} a = %get (intervalRef ref)
def getCode (ref: Ref h (a&b)) : {State h} b = %get (codeRef ref)
def getTally (ref: Ref h (a&(b&c&d))) : {State h} d = %get (tallyRef ref)

def encodeSymbol (str: (Fin l)=>Word8) 
              (model: Alphabet=>(Interval->Interval)) 
              (i: (Fin l)) 
              (params: (Interval&Code)) : (Interval&Code) =
  yieldState params \p.
    (low, high) = model.((charToIdx str.i)@_) (getInterval p)
    (low', high') = if high < half
      then
        codeRef p := enqueue 0 (getCode p)
        (low, high)
      else if low >= half
        then
          codeRef p := enqueue 1 (getCode p)
          (low-half, high-half)
        else
          tallyRef p := getTally p + 1
          (low-fstQuarter, high-fstQuarter)
    intervalRef p := (2*low', 2*(high'+1)-1)

def encode (str: (Fin l)=>Word8) (model: Alphabet=>(Interval->Interval)) : Code =
  update = encodeSymbol str model
  initInterval = (0,maxInt-1)
  snd $ fold (initInterval,(0,0,0)) update

def decodeSymbol  (l: Int)
                  (model: Alphabet=>(Interval->Interval))
                  (i: (Fin l))
                  (params: ((Interval&Code)&List Word8)) : ((Interval&Code)&List Word8) =
  yieldState params \ref.
    fstRef := yieldState (fst params) \p.
      (code, bit) = dequeue (getCode p)
      codeRef p := code
      interv = getInterval p
      symbol = boundedIter (size Alphabet) (' ') \j.
        case model.(j@_) interv == interv of
          True -> Continue
          False ->
            (low, high) = model.(j@_) interv 
            case code >= x && code < (x+w) of
              True -> Done (idxToChar j, (x,w))
              False -> Continue
      sndRef := (str <> AsList 1 [symbol], in')

def decode (l: Int) (code: Int) (model: Alphabet=>(Interval->Interval)) : List Word8 =
  update = decodeSymbol l code model
  initStr: List Word8 = AsList _ []
  initInterval = (0,maxInt-1)
  snd $ fold ((initInterval, code), initStr) update

'Lossless compression on a test string

str' = "abccedac"
(AsList l str) = str'
initInterval = (0,maxInt-1)
m = model str
m.(0@_) initInterval
m.(1@_) initInterval
m.(2@_) initInterval
m.(3@_) initInterval
m.(4@_) initInterval

code = encode str m
code
> 0.081569

decoded = decode l code m
decoded == str'
> True



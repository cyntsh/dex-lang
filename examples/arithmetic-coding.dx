'## Arithmetic coding
A finite-precision variant based on [this](https://web.stanford.edu/class/ee398a/handouts/papers/WittenACM87ArithmCoding.pdf) paper by Ian H. Witten et al.

Alphabet = Fin 26
Interval = (Int&Int)
Code = (Int&Int&Int)
Buffer = Int
maxBits = 7
maxInt = intpow2 maxBits
half = idiv maxInt 2
fstQuarter = idiv half 2
thdQuarter = fstQuarter * 3

def charToIdx (c: Word8) : Int = W8ToI c - W8ToI 'a'
def idxToChar (i: Int) : Word8 = IToW8 (i + (W8ToI 'a'))

'### Statistical modelling

def norm (freq: Int) (l: Int) (w: Int) : Int = FToI $ IToF freq / IToF l * IToF w
def inverseNorm (norm: Int) (l: Int) (w: Int) : Int = FToI $ IToF norm / IToF w * IToF l

def getCumFreq (fs: Alphabet=>Int) : Alphabet=>Int =
  withState zero \total.
    for i. if fs.i /= zero
      then
        newTotal = get total + fs.i
        total := newTotal
        newTotal
      else zero

def getIntervals (xs: Alphabet=>Int) : Alphabet=>Interval =
  withState (0,0) \ref.
    for i. if xs.i /= zero
      then
        ref := ((snd (get ref)), xs.i)
        get ref
      else (0,0)

def getFrequency (str: (Fin l)=>Word8) : Alphabet=>Int =
  a: Alphabet => Int = zero
  yieldState a \ref. for i. 
    i' = (charToIdx str.i)@_
    ref!i' := (get ref).i' + 1

def model (str: (Fin l)=>Word8) : Alphabet=>(Interval->Interval) =
  freq = getFrequency str
  cumFreq = getCumFreq freq
  inFreq = getIntervals cumFreq
  for i.
    case inFreq.i == (0,0) of
      True -> id
      False ->
        (fLow, fHigh) = inFreq.i
        \(low, high).
          w = high-low+1
          low' = low + norm fLow l w
          high' = low-1 + norm fHigh l w
          (low', high')

'### Integer arithmetic

def enqueue (bit: Int) ((code, numBits, tally): Code) : Code =
  half = intpow2 numBits
  case bit==1 of 
    True -> (%or code half, numBits+tally+1, 0)
    False -> 
      (code', numBits') = yieldState (code, numBits+1) \ref. for i:(Fin tally).
        (code', numBits') = get ref
        half' = intpow2 numBits'
        ref := (%or code' half', numBits'+1)
      (code', numBits', 0)

def dequeue ((code, buffer, tally): Code) : Code = (%shr code (1+tally), 2*buffer+%and 1 code, 0)

'### Scaling functions

def encodeInterval ((low, high): Interval) (code: Code) : (Int&Int&Code&(IterResult Int)) =
  case high < half of
    True ->
      (2*low,
       2*high+1,
       enqueue 0 code,
       Continue)
    False -> case low >= half of
      True ->
        (2*(low - half),
         2*(high - half)+1,
         enqueue 1 code,
         Continue)
      False -> case high < thdQuarter && low >= fstQuarter of
        True ->
          (2*(low - fstQuarter), 
           2*(high - fstQuarter)+1, 
           (fst code, fst (snd code), snd (snd code) + 1), 
           Continue)
        False -> (low, high, code, Done 0)

def encodeSymbol (str: (Fin l)=>Word8) 
              (model: Alphabet=>(Interval->Interval)) 
              (i: (Fin l)) 
              (params: (Interval&Code)) : (Interval&Code) =
  yieldState params \p.
    intervalRef = fstRef p
    codeRef = sndRef p
    intervalRef := model.((charToIdx str.i)@_) (get intervalRef)
    boundedIter maxBits 0 \_.
      (low, high, code, result) = encodeInterval (get intervalRef) (get codeRef)
      intervalRef := (low, high)
      codeRef := code
      result

def findInterval (interval: Interval) (buff: Int) (model: Alphabet=>(Interval->Interval)) : (Word8&Interval)=
  boundedIter (size Alphabet) (' ',(0,0)) \j.
    case model.(j@_) interval == interval of
      True -> Continue
      False ->
        (low, high) = model.(j@_) interval
        case buff >= low && buff < high of
          True -> Done (idxToChar j, (low,high))
          False -> Continue

def decodeInterval ((low, high): Interval) (code: Code) : (Int&Int&Code&(IterResult Int)) =
  case high < half of
    True ->
      (2*low,
       2*high+1,
       dequeue code,
       Continue)
    False -> case low >= half of
      True ->
        (x, buffer, z) = code
        (2*(low-half),
         2*(high-half)+1,
         dequeue (x, buffer-half, z),
         Continue)
      False -> case high < thdQuarter && low >= fstQuarter of
        True ->
          (x, buffer, z) = code
          (2*(low-fstQuarter),
           2*(high-fstQuarter)+1,
           dequeue (x, buffer-fstQuarter, z),
           Continue)
        False -> (low, high, code, Done 0)

def decodeSymbol  (l: Int)
                  (model: Alphabet=>(Interval->Interval))
                  (i: (Fin l))
                  (params: (Interval&Code&List Word8)) : (Interval&Code&List Word8) =
  yieldState params \p.
    intervalRef = fstRef p
    codeRef = fstRef (sndRef p)
    strRef = sndRef (sndRef p)
    bufferRef = fstRef (sndRef codeRef)
    (symbol, interval) = findInterval (get intervalRef) (get bufferRef) model
    strRef := get strRef <> AsList 1 [symbol]
    intervalRef := interval
    boundedIter maxBits 0 \_.
      (low, high, code, result) = decodeInterval (get intervalRef) (get codeRef)
      intervalRef := (low, high)
      codeRef := code 
      result

'### Coding interface

def encode (str: (Fin l)=>Word8) (model: Alphabet=>(Interval->Interval)) : Int =
  update = encodeSymbol str model
  initInterval = (0,maxInt-1)
  fst $ snd $ fold (initInterval,(0,0,0)) update

def decode (l: Int) (code: Int) (model: Alphabet=>(Interval->Interval)) : List Word8 =
  update = decodeSymbol l model
  initStr: List Word8 = AsList _ []
  initInterval = (0,maxInt-1)
  initCode' = (code, 0, 0)
  initCode = yieldState initCode' \ref. for i:(Fin maxBits). ref := dequeue (get ref)
  snd $ snd $ fold (initInterval, initCode, initStr) update

'### Demo: Lossless compression on a test string

str' = "abccedac"
(AsList l str) = str'
m = model str

code = encode str m
code
> 60584

decoded = decode l code m
decoded
> (AsList 8 "abccedaa")
decoded == str'
> False






'## Arithmetic coding
A finite-precision variant based on [this](https://web.stanford.edu/class/ee398a/handouts/papers/WittenACM87ArithmCoding.pdf) paper by Ian H. Witten et al.

Alphabet = Fin 26
Interval = (Int&Int)
Code = ((List Int)&Int&Int)
maxBits = 31
precision = 7
top = intpow2 precision
half = idiv top 2
fstQuarter = idiv half 2
thdQuarter = fstQuarter * 3

def charToIdx (c: Word8) : Int = W8ToI c - W8ToI 'a'
def idxToChar (i: Int) : Word8 = IToW8 (i + (W8ToI 'a'))

'### Statistical modelling

def norm (freq: Int) (l: Int) (w: Int) : Int = FToI $ IToF freq / IToF l * IToF w
def inverseNorm (norm: Int) (l: Int) (w: Int) : Int = FToI $ IToF norm / IToF w * IToF l

def getCumFreq (fs: Alphabet=>Int) : Alphabet=>Int =
  withState zero \total.
    for i. if fs.i /= zero
      then
        newTotal = get total + fs.i
        total := newTotal
        newTotal
      else zero

def getIntervals (xs: Alphabet=>Int) : Alphabet=>Interval =
  withState (0,0) \ref.
    for i. if xs.i /= zero
      then
        ref := ((snd (get ref)), xs.i)
        get ref
      else (0,0)

def getFrequency (str: (Fin l)=>Word8) : Alphabet=>Int =
  a: Alphabet => Int = zero
  yieldState a \ref. for i. 
    i' = (charToIdx str.i)@_
    ref!i' := get ref!i' + 1

def model (str: (Fin l)=>Word8) : Alphabet=>(Interval->Interval) =
  freq = getFrequency str
  cumFreq = getCumFreq freq
  inFreq = getIntervals cumFreq
  for i.
    case inFreq.i == (0,0) of
      True -> id
      False ->
        (fLow, fHigh) = inFreq.i
        \(low, high).
          w = high-low+1
          low' = low + norm fLow l w
          high' = low-1 + norm fHigh l w
          (low', high')

'### Integer arithmetic

def overflowing (numBits: Int) : Bool = 
  mod numBits maxBits == 0 && numBits > maxBits

def existsOverflow (numBits: Int) : Bool =
  mod numBits maxBits > 0 && numBits > maxBits

def selectStream (numBits: Int) (code: Ref h Int) 
                 (overflow: Ref h Int) : {State h} Unit =
  numBits' = mod numBits maxBits
  bitMask = intpow2 numBits'
  case (numBits < maxBits) of 
    True -> code := %or (get code) bitMask
    False -> overflow := %or (get overflow) bitMask

def enqueue (bit: Int) ((codeLst, numBits, tally): Code) : Code =
  (AsList numInts intArr) = codeLst
  code = intArr.((numInts-1)@_)
  overflow = (0, AsList 0 [])

  (code', overflow', numBits') = yieldState (code, overflow, numBits) \ref.
    codeRef = fstRef ref
    overflowRef = fstRef (fstRef (sndRef ref))
    lstOverflowRef = sndRef (fstRef (sndRef ref))
    bitsRef = sndRef (sndRef ref)

    if bit==1 then selectStream (get bitsRef) codeRef overflowRef
    bitsRef := (get bitsRef)+1
    if overflowing (get bitsRef) then 
      lstOverflowRef := (get lstOverflowRef) <> (AsList 1 [get overflowRef])
      overflowRef := 0

    for i:(Fin tally).
      if bit==0 then selectStream (get bitsRef) codeRef overflowRef
      bitsRef := (get bitsRef)+1
      if overflowing (get bitsRef) then 
        lstOverflowRef := (get lstOverflowRef) <> (AsList 1 [get overflowRef])
        overflowRef := 0

    if existsOverflow (get bitsRef) then
      lstOverflowRef := (get lstOverflowRef) <> (AsList 1 [get overflowRef])

  intArr' = yieldState intArr \arr. arr!((numInts-1)@_) := code'
  codeLst' = (AsList numInts intArr') <> (snd overflow')
  (codeLst', mod numBits' maxBits, 0)

def dequeue ((codeLst, bitPos, tally): Code) (buffer: Int): (Code&Int) = 
  (AsList numInts intArr) = codeLst
  codePos = idiv (bitPos) maxBits -- initial bitPos is 1
  code = intArr.(codePos@_)
  bit = %and 1 code

  (intArr', buffer', bitPos') = yieldState (intArr, 2*buffer+bit, bitPos) \ref.
    arrRef = fstRef ref
    bufferRef = fstRef (sndRef ref)
    posRef = sndRef (sndRef ref) 
    arrRef!(codePos@_) := %shr code 1

    for i:(Fin tally).
      codePos = idiv (get posRef) maxBits
      code = get arrRef!(codePos@_)
      bit = %and 1 code
      bufferRef := 2*(get bufferRef) + bit
      arrRef!(codePos@_) := %shr code 1
      posRef := (get posRef) + 1

  codeLst' = AsList numInts intArr'
  ((codeLst', bitPos', 0), buffer')

'### Scaling functions

def encodeInterval ((low, high): Interval) (code: Code) : (Int&Int&Code&(IterResult Int)) =
  case high < half of
    True ->
      (2*low,
       2*high+1,
       enqueue 0 code,
       Continue)
    False -> case low >= half of
      True ->
        (2*(low - half),
         2*(high - half)+1,
         enqueue 1 code,
         Continue)
      False -> case high < thdQuarter && low >= fstQuarter of
        True ->
          (2*(low - fstQuarter), 
           2*(high - fstQuarter)+1, 
           (fst code, fst (snd code), snd (snd code) + 1), 
           Continue)
        False -> (low, high, code, Done 0)

def encodeSymbol (str: (Fin l)=>Word8) 
              (model: Alphabet=>(Interval->Interval)) 
              (i: (Fin l)) 
              (params: (Interval&Code)) : (Interval&Code) =
  yieldState params \p.
    intervalRef = fstRef p
    codeRef = sndRef p
    intervalRef := model.((charToIdx str.i)@_) (get intervalRef)
    boundedIter precision 0 \_.
      (low, high, code, result) = encodeInterval (get intervalRef) (get codeRef)
      intervalRef := (low, high)
      codeRef := code
      result

def findInterval (interval: Interval) (buffer: Int) 
                 (model: Alphabet=>(Interval->Interval)) : (Word8&Interval)=
  boundedIter (size Alphabet) (' ',(0,0)) \j.
    case model.(j@_) interval == interval of
      True -> Continue
      False ->
        (low, high) = model.(j@_) interval
        case buffer >= low && buffer < high of
          True -> Done (idxToChar j, (low,high))
          False -> Continue

def decodeInterval ((low, high): Interval) 
                   (code: Code) (buffer: Int) : (Int&Int&Code&Int&(IterResult Int)) =
  case high < half of
    True ->
      (2*low,
       2*high+1,
       dequeue code,
       Continue)
    False -> case low >= half of
      True ->
        (x, buffer, z) = code
        (2*(low-half),
         2*(high-half)+1,
         dequeue (x, buffer-half, z),
         Continue)
      False -> case high < thdQuarter && low >= fstQuarter of
        True ->
          (x, buffer, z) = code
          (2*(low-fstQuarter),
           2*(high-fstQuarter)+1,
           dequeue (x, buffer-fstQuarter, z),
           Continue)
        False -> (low, high, code, Done 0)

def decodeSymbol  (l: Int)
                  (model: Alphabet=>(Interval->Interval))
                  (i: (Fin l))
                  (params: (Interval&Code&Int&List Word8)) : (Interval&Code&Int&List Word8) =
  yieldState params \p.
    intervalRef = fstRef p
    codeRef = fstRef (sndRef p)
    strRef = sndRef (sndRef (sndRef p))
    bufferRef = fstRef (sndRef (sndRef p))
    (symbol, interval) = findInterval (get intervalRef) (get bufferRef) model
    strRef := get strRef <> AsList 1 [symbol]
    intervalRef := interval
    boundedIter precision 0 \_.
      (low, high, code, result) = decodeInterval (get intervalRef) (get codeRef)
      intervalRef := (low, high)
      codeRef := code 
      result

'### Coding interface

def encode (str: (Fin l)=>Word8) (model: Alphabet=>(Interval->Interval)) : List Int =
  update = encodeSymbol str model
  initInterval = (0,top-1)
  fst $ snd $ fold (initInterval,(AsList 1 [0],0,0)) update

def decode (l: Int) (codeLst: List Int) (model: Alphabet=>(Interval->Interval)) : List Word8 =
  update = decodeSymbol l model
  initStr: List Word8 = AsList _ []
  initInterval = (0,top-1)
  initCode' = (codeLst, 1, 0)
  initCode = yieldState initCode' \ref. for i:(Fin precision). ref := dequeue (get ref)
  snd $ snd $ fold (initInterval, initCode, 0, initStr) update

'### Demo: Lossless compression on a test string

str' = "edacg"
(AsList l str) = str'
m = model str

code = encode str m
code
> (AsList 1 [821])

decoded = decode l code m
decoded
> 
decoded == str'
> 








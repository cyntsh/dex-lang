'### Arithmetic coding
A finite-precision variant based on [this](https://web.stanford.edu/class/ee398a/handouts/papers/WittenACM87ArithmCoding.pdf) paper by Ian H. Witten et al.

Alphabet = Fin 26
Interval = (Int&Int)
Code = (Int&Int&Int)
maxBits = 7
maxInt = intpow2 maxBits
half = idiv maxInt 2
fstQuarter = idiv half 2
thdQuarter = fstQuarter * 3

def charToIdx (c: Word8) : Int = W8ToI c - W8ToI 'a'
def idxToChar (i: Int) : Word8 = IToW8 (i + (W8ToI 'a'))
def intToBin (i: Int) : List Word8 = "WIP"

'Statistical modelling

def normalize (freq: Int) (l: Int) (w: Int) : Int = FToI $ IToF freq / IToF l * IToF w

def getCumFreq (fs: Alphabet=>Int) : Alphabet=>Int =
  withState zero \total.
    for i. if fs.i /= zero
      then
        newTotal = get total + fs.i
        total := newTotal
        newTotal
      else zero

def getIntervals (xs: Alphabet=>Int) : Alphabet=>Interval =
  withState (0,0) \ref.
    for i. if xs.i /= zero
      then
        ref := ((snd (get ref)), xs.i)
        get ref
      else (0,0)

def getFrequency (str: (Fin l)=>Word8) : Alphabet=>Int =
  a: Alphabet => Int = zero
  yieldState a \ref. for i. 
    i' = (charToIdx str.i)@_
    ref!i' := (get ref).i' + 1

def model (str: (Fin l)=>Word8) : Alphabet=>(Interval->Interval) =
  freq = getFrequency str
  cumFreq = getCumFreq freq
  inFreq = getIntervals cumFreq
  for i.
    case inFreq.i == (0,0) of
      True -> id
      False ->
        (fLow, fHigh) = inFreq.i
        \(low, high).
          w = high-low+1
          low' = low + normalize fLow l w
          high' = low-1 + normalize fHigh l w
          (low', high')

'Encoding arithmetic

def appendBit (b: Int) ((code, numBits, tally): Code) : Code =
  half = intpow2 numBits
  case b==1 of 
    True -> (%or code half, numBits+tally+1, 0)
    False -> 
      (code', numBits') = yieldState (code, numBits+1) \ref. for i:(Fin tally).
        (code', numBits') = get ref
        half' = intpow2 numBits'
        ref := (%or code' half', numBits'+1)
      (code', numBits', 0)

appendBit 1 (2,5,0)

def intervalRef (ref: Ref h (a&b)) : Ref h a = %fstRef ref
def codeRef (ref: Ref h (a&b)) : Ref h b = %sndRef ref
def tallyRef (ref: Ref h (a&(b&c&d))) : Ref h d = %sndRef (%sndRef (%sndRef ref))

def getInterval (ref: Ref h (a&b)) : {State h} a = %get (intervalRef ref)
def getCode (ref: Ref h (a&b)) : {State h} b = %get (codeRef ref)
def getTally (ref: Ref h (a&(b&c&d))) : {State h} d = %get (tallyRef ref)

def shiftInterval (str: (Fin l)=>Word8) 
              (model: Alphabet=>(Interval->Interval)) 
              (i: (Fin l)) 
              (params: (Interval&Code)) : (Interval&Code) =
  yieldState params \ref.
    (low, high) = model.((charToIdx str.i)@_) (getInterval ref)
    (low', high') = if high < half
      then
        codeRef ref := appendBit 0 (getCode ref)
        (low, high)
      else if low > half
        then
          codeRef ref := appendBit 1 (getCode ref)
          (low-half, high-half)
        else
          tallyRef ref := getTally ref + 1
          (low-fstQuarter, high-fstQuarter)
    intervalRef ref := (2*low', 2*(high'+1)-1) -- high is an open boundary

def encode (str: (Fin l)=>Word8) (model: Alphabet=>(Interval->Interval)) : Code =
  update = shiftInterval str model
  initInterval = (0,maxInt-1)
  snd $ fold (initInterval,(0,0,0)) update

def findInterval  (l: Int)
                  (rule: Alphabet=>(Interval->Interval))
                  (i: (Fin l))
                  (params: (Interval&Code&List Word8)) : (Interval&Code&List Word8) =
  (letter, in') = boundedIter (size Alphabet) (' ', top) \j.
    case rule.(j@_) in == in of
      True -> Continue
      False ->
        (x, w) = rule.(j@_) in 
        case code >= x && code < (x+w) of
          True -> Done (idxToChar j, (x,w))
          False -> Continue
  (str <> AsList 1 [letter], in')

def decode (l: Int) (code: Int) (model: Alphabet=>(Interval->Interval)) : List Word8 =
  update = findInterval l code model
  initStr: List Word8 = AsList _ []
  initInterval = (0,maxInt-1)
  snd $ fold (initInterval, code, initStr) update

'Lossless compression on a test string

str' = "abccedacabccedac"
(AsList l str) = str'
initInterval = (0,maxInt-1)
m = model str
m.(0@_) initInterval
m.(1@_) initInterval
m.(2@_) initInterval
m.(3@_) initInterval
m.(4@_) initInterval

code = encode str m
code
> 0.081569

decoded = decode l code m
decoded == str'
> True




